
// //pre-headers (suggested)
// //SPS: 00 00 00 01 ; 67 42 00 28 da 05 82 59 	// contains size of image 352x288
// //PPS: 00 00 00 01 ; 68 ce 38 80				// default zero params
// //Slice: 00 00 00 01 (rest of slice is generated by h264header).

module h264top()

    localparam verbose  = 1'b0;             ////dump all output bits and states	
	localparam verbose2 = 1'b0;	            ////dump residuals, coeffs, etc
	localparam verbose3 = 1'b0;	            ////dc checks; dump dc coeffs
	localparam verbosep = 1'b1;	            ////progress indicator "newline pulsed"
	localparam dumprecon = 1'b1;	        ////dump reconstructed image to file
	localparam computesnr = 1'b1;	        ////compute and print SNR figures
	// //
	// //localparam IMGWIDTH : integer := 4000;
	// //localparam IMGHEIGHT : integer := 2672;
	// //localparam IMGSKIP : integer := 8;

	localparam [31:0] IMGWIDTH = 32'd352;	////sample stuff is 352x288
	localparam [31:0] IMGHEIGHT = 32'd288;
	// //localparam IMGWIDTH : integer := 320;
	// //localparam IMGHEIGHT : integer := 128;
	localparam [31:0] IMGSKIP = 32'd0;		////amount to skip between lines (usually 0)
	localparam [31:0] MAXFRAMES = 32'd150;	////number of frames to process
	localparam [31:0] INITQP = 32'd28;	    ////0..51
	localparam [31:0] MAXQP = INITQP;
	localparam [31:0] IWBITS = 32'd9;		////bits required for IMGWIDTH
	
    localparam [31:0] bytefile [7:0];
    localparam [IMGWIDTH-1:0][IMGHEIGHT-1:0] Tvideoframe [7:0]
    localparam [IMGWIDTH>>1-1:0][IMGHEIGHT>>1-1:0] Tchromaframe [7:0]
	parameter yvideo = Tvideoframe ;
    parameter uvideo = Tchromaframe;
    parameter vvideo = Tchromaframe;
	
    logic slowready = 1'b1;             ////to run it slowly, keep this sometimes at 0
	logic [32:0] slowcount = 32'd0;
	logic slowready = 1'b1;	
	logic [32:0] iiy = 32'd0;   ////debug
	logic [32:0] ccy = 32'd0;   ////debug
	
	logic CLK = 1'b0;			////clock
	logic CLK2 ;				////2x clock

	//// THIS SECTION IS SKELETON FOR HARDWARE SYNTH...

	logic top_NEWSLICE = 1'b1;			        //reset: this is the first a slice
	logic top_NEWLINE = 1'b0;			        //newline: first mb and submb
	logic intra4x4_READYI = 1'b0;				//ready for enable when this set
	logic intra4x4_STROBEI = 1'b0;				//values transfered only when this is 1
	logic [31:0] intra4x4_DATAI = 32'd0;
	logic [31:0] intra4x4_TOPI = 32'd0;
	logic [3:0] intra4x4_TOPMI = 4'd0;
	logic intra4x4_STROBEO = 1'b0;			    //values transfered out when this is 1
	logic intra4x4_READYO = 1'b0;				//when ready for out
	logic [35:0] intra4x4_DATAO = 36'd0;
	logic [31:0] intra4x4_BASEO = 32'd0;
	logic intra4x4_MSTROBEO = 1'b0;		        //mode transfered only when this is 1	
	logic [3:0] intra4x4_MODEO = 4'd0;	        //0..8 prediction type
	logic intra4x4_PMODEO = 1'b0;               //prediction type same
	logic [2:0] intra4x4_RMODEO = 3'd0;	        //prediction type rem
	logic [1:0] intra4x4_XXO = 2'd0
	logic intra4x4_XXINC = 1'b0;
	logic intra4x4_CHREADY = 1'b0;
	//
	logic intra8x8cc_readyi = 1'b0;			    //ready for enable when this set
	logic intra8x8cc_strobei = 1'b0;			//values transfered only when this is 1
	logic [31:0] intra8x8cc_datai = 32'd0;
	logic [31:0] intra8x8cc_TOPI = 32'd0;
	logic intra8x8cc_STROBEO = 1'b0;			//values transfered out when this is 1
	logic intra8x8cc_READYO = 1'b0;			    //when ready for out
	logic [35:0] intra8x8cc_DATAO = 36'd0;
	logic [31:0] intra8x8cc_BASEO = 32'd0;
	logic intra8x8cc_dcstrobeo = 1'b0;			//when ready for out
	logic [15:0] intra8x8cc_dcdatao = 16'd0;
	logic [1:0] intra8x8cc_CMODEO = 2'd0;	    //0..8 prediction type
	logic [1:0] intra8x8cc_XXO = 2'd0;
	logic intra8x8cc_XXC = 1'b0;
	logic intra8x8cc_XXINC = 1'b0;
	//
	logic [1:0] header_CMODE = 2'b00;	        //intra_chroma_pred_mode
	logic [19:0] header_VE = 20'd0;
	logic [4:0] header_VL = 5'd0;
	logic header_VALID = 1'b0;                  // VE/VL valid
	//
	logic coretransform_READY = 1'b0;			//ready for enable when this set
	logic coretransform_ENABLE = 1'b0;			//values transfered only when this is 1
	logic [35:0] coretransform_XXIN = 36'd0;
	logic coretransform_valid = 1'b0;
	logic [13:0] coretransform_ynout = 14'd0;
	//
	logic dctransform_VALID = 1'b0;
	logic [15:0] dctransform_yyout = 16'd0;
	logic dctransform_readyo = 1'b0;
	//
	logic quantise_ENABLE = 1'b0;
	logic [15:0] quantise_YNIN = 16'd0;
	logic quantise_valid = 1'b0;
	logic [11:0] quantise_zout = 12'd0;
	logic quantise_dcco = 1'b0;
	//
	logic dequantise_enable = 1'b0;
	logic [15:0] dequantise_zin = 16'd0;
	logic dequantise_last = 1'b0;
	logic dequantise_valid = 1'b0;
	logic dequantise_dcco = 1'b0;
	logic [15:0] dequantise_wout = 16'd0;
	//
	logic invdctransform_enable = 1'b0;
	logic [15:0] invdctransform_zin = 16'd0;
	logic invdctransform_valid = 1'b0;
	logic [15:0] invdctransform_yyout = 16'd0;
	logic invdctransform_ready = 1'b0;
	//
	logic invtransform_valid = 1'b0;
	logic [39:0] invtransform_xout = 40'd0;
	//
	logic recon_BSTROBEI = 1'b0;			//values transfered only when this is 1
	logic [31:0] recon_basei = 32'd0;
	logic recon_FBSTROBE = 1'b0;			//feedback transfered only when this is 1
	logic recon_FBCSTROBE = 1'b0;			//feedback transfered only when this is 1
	logic [31:0] recon_FEEDB = 32'd0;
	//
	logic xbuffer_NLOAD = 1'b0;	            //load for CAVLC NOUT
	logic [2:0] xbuffer_NX = 3'd0;      	//X value for NIN/NOUT
	logic [2:0] xbuffer_NY = 3'd0;      	//Y value for NIN/NOUT
	logic [1:0] xbuffer_NV = 2'd0;      	//valid flags for NIN/NOUT (1=left, 2=top, 3=avg)
	logic xbuffer_NXINC = 1'b0;	            //increment for X macroblock counter
	logic xbuffer_READYI = 1'b0;
	logic xbuffer_CCIN = 1'b0;
	logic xbuffer_DONE = 1'b0;
	//
	logic cavlc_ENABLE = 1'b0;			    //values transfered only when this is 1
	logic cavlc_READY ;				        //values transfered only when this is 1
	logic [11:0] cavlc_VIN = 11'h000;		//12bits max (+/- 2048)
	logic [4:0] cavlc_NIN =5'b00000;	    //N coeffs nearby mb
	logic [24:0] cavlc_VE = 25'd0;
	logic [4:0] cavlc_VL = 5'd0;
	logic cavlc_VALID = 1'b0;               // enable delayed to same as VE/VL
	logic [2:0] cavlc_XSTATE = 3'd0;
	logic [4:0] cavlc_NOUT = 5'd0;
	//
	logic tobytes_READY ;					//soft "ready" flag
	logic [24:0] tobytes_VE = 25'd0;
	logic [4:0] tobytes_VL = 5'd0;
	logic tobytes_VALID = 1'b0;             // VE/VL1 valid
	logic [7:0] tobytes_BYTE = 8'd0;
	logic tobytes_STROBE = 1'b0;            // BYTE valid
	logic tobytes_DONE = 1'b0;	            // NAL all done
	//
	logic align_VALID = 1'b0;
	logic [5:0] QP = CONV_STD_LOGIC_VECTOR(INITQP,6);
	//
	logic [7:0] ninx = 8'h00;	            //N coeffs nearby mb: left
	logic [4:0] ninl = 5'b00000;	        //N coeffs nearby mb: left
	logic [4:0] nint = 5'b00000;	        //N coeffs nearby mb: top
	logic [5:0] ninsum = 5'b000000;	        //N coeffs nearby mb
	type Tnin is array (natural range <>) of std_logic_vector(4 downto 0);
	logic ninleft : Tnin(7 downto 0) := (others=>(others=>'0'));
	logic nintop : Tnin(2047 downto 0) := (others=>(others=>'0'));	//macroblocks*8
	//
	type Tfullrow is array (0 to IMGWIDTH-1) of std_logic_vector(31 downto 0);
	type Tfullrowm is array (0 to IMGWIDTH-1) of std_logic_vector(3 downto 0);
	logic toppix : Tfullrow := (others=>(others=>'0'));	//actually units of 4 pixels
	logic toppixcc : Tfullrow := (others=>(others=>'0'));	//actually units of 4 pixels
	logic topmode : Tfullrowm := (others=>x"0");
	logic mbx : std_logic_vector(IWBITS-1 downto 0) := (others=>'0');	//macroblock x counter
	logic mbxcc : std_logic_vector(IWBITS-1 downto 0) := (others=>'0'); //macroblock x counter for chroma
	//
initial begin
    h264intra4x4 intra4x4(.CLK(CLK2), .NEWSLICE(top_NEWSLICE), .STROBEI(intra4x4_strobei),
                           .DATAI(intra4x4_datai), .READYI(intra4x4_readyi),
                           .TOPI(intra4x4_topi), .TOPMI(intra4x4_topmi), .XXO(intra4x4_xxo),
                           .XXINC(intra4x4_xxinc), .FEEDBI(recon_FEEDB[31:24]), .FBSTROBE(recon_FBSTROBE),
                           .STROBEO(intra4x4_strobeo), .DATAO(intra4x4_datao), .BASEO(intra4x4_baseo),
                           .READYO(intra4x4_readyo), .MODEO(intra4x4_MODEO), .PMODEO(intra4x4_PMODEO),
                           .RMODEO(intra4x4_RMODEO), .CHREADY(intra4x4_CHREADY));
	
		
	intra4x4_readyo <= coretransform_ready & xbuffer_readyi;    // and slowready;
	intra4x4_TOPI <= toppix(conv_integer(mbx & intra4x4_XXO));
	intra4x4_TOPMI <= topmode(conv_integer(mbx & intra4x4_XXO));
	//
	h264intra8x8cc intra8x8cc(.CLK2(CLK2), .NEWSLICE(top_NEWSLICE), .NEWLINE(top_NEWLINE), 
                               .STROBEI(intra8x8cc_strobei), .DATAI(intra8x8cc_datai), .READYI(intra8x8cc_readyi),
                               .TOPI(intra8x8cc_topi), .XXO(intra8x8cc_xxo), .XXC(intra8x8cc_xxc),
                               .XXINC(intra8x8cc_xxinc), .FEEDBI(recon_FEEDB[31:24]), .FBSTROBE(recon_FBSTROBE),
                               .STROBEO(intra8x8cc_strobeo), .DATAO(intra8x8cc_datao), .BASEO(intra8x8cc_baseo),
                               .READYO(intra4x4_CHREADY), .DCSTROBEO(intra8x8cc_dcstrobeo), 
                               .DCDATAO(intra8x8cc_dcdatao), .CMODEO(intra8x8cc_cmodeo));
	
	intra8x8cc_TOPI <= toppixcc(conv_integer(mbxcc & intra8x8cc_XXO));
	//
	h264header header(.CLK(CLK), .NEWSLICE(top_NEWSLICE), .SINTRA(1'b1), .MINTRA(1'b1),
                       .LSTROBE(intra4x4_strobeo), .CSTROBE(intra4x4_strobeo), .QP(qp),
                       .PMODE(intra4x4_PMODEO), .RMODE(intra4x4_RMODEO), .CMODE(header_cmode),
                       .PTYPE(2'b00), .PSUBTYPE(2'b00), .MVDX(12'h000), .MVDY(12'h000),
                       .VE(header_ve), .VL(header_vl), .VALID(header_valid));
	
	//
	h264coretransform coretransform(.CLK(CLK2), .READY(coretransform_ready), .ENABLE(coretransform_enable),
                                    .XXIN(coretransform_xxin), .VALID(coretransform_valid), .YNOUT(coretransform_ynout));
	
	coretransform_enable <= (intra4x4_strobeo | intra8x8cc_strobeo);
	coretransform_xxin <= intra4x4_datao when intra4x4_strobeo='1' else intra8x8cc_datao;
	recon_bstrobei <= intra4x4_strobeo or intra8x8cc_strobeo;
	recon_basei <= intra4x4_baseo when intra4x4_strobeo='1' else intra8x8cc_baseo;
	//
	h264dctransform dctransform(.CLK2(CLK2), .RESET(top_newslice), .ENABLE(intra8x8cc_dcstrobeo),
                                .XXIN(intra8x8cc_dcdatao), .VALID(dctransform_valid), .YNOUT(dctransform_yyout),
                                .READYO(dctransform_readyo));
	
	dctransform_readyo <= (intra4x4_CHREADY & (!coretransform_valid));
	//
	h264quantise quantise(.CLK(CLK2), .ENABLE(quantise_ENABLE), .QP(qp), .DCCI(dctransform_VALID),
   
	quantise_YNIN <= sxt(coretransform_ynout,16) when coretransform_valid='1' else dctransform_yyout;
	quantise_ENABLE <= coretransform_valid or dctransform_VALID;
	//
	h264dctransform invdctransform(.CLK2(CLK2), .RESET(top_newslice), .ENABLE(invdctransform_enable),
                                    .XXIN(invdctransform_zin), .VALID(invdctransform_valid), .YYOUT(invdctransform_yyout),
                                    .READYO(invdctransform_ready));
	
	invdctransform_enable <= quantise_valid and quantise_dcco;
	invdctransform_ready <= dequantise_last and xbuffer_CCIN;
	invdctransform_zin <= sxt(quantise_zout,16);
	//
	h264dequantise dequantise(.LASTADVANCE(8'd2), . CLK(CLK2), .ENABLE(dequantise_enable), .QP(qp),
                              .ZIN(dequantise_zin), .DCCI(invdctransform_valid), .LAST(dequantise_last),
                              .WOUT(dequantise_wout), .VALID(dequantise_valid));
	
	dequantise_enable <= quantise_valid and not quantise_dcco;
	dequantise_zin <= sxt(quantise_zout,16) when invdctransform_valid='0' else invdctransform_yyout;
	//
    h264invtransform invdctransform(.CLK(CLK2), .ENABLE(dequantise_valid), .WIN(dequantise_wout),
                                    .VALID(invtransform_valid), .XOUT(invtransform_xout));

	//
	h264recon recon(.CLK2(CLK2), .NEWSLICE(top_NEWSLICE), .STROBEI(invtransform_valid), .DATAI(invtransform_xout),
                    .BSTROBEI(recon_bstrobei), .BCHROMAI(intra8x8cc_strobeo), .BASEI(recon_basei),
                    .STROBEO(recon_FBSTROBE), .CSTROBEO(recon_FBCSTROBE), .DATAO(recon_FEEDB));

	//
	h264buffer xbuffer(.CLK(CLK2), .NEWSLICE(top_NEWSLICE), .NEWLINE(top_NEWLINE), .VALIDI(quantise_valid),
                        .ZIN(quantise_zout), .READYI(xbuffer_READYI), .CCIN(xbuffer_CCIN), .DONE(xbuffer_DONE),
                        .VOUT(cavlc_vin), .VALIDO(cavlc_enable), .NLOAD(xbuffer_NLOAD), .NX(xbuffer_NX),
                        .NY(xbuffer_NY), .NV(xbuffer_NV), .NXINC(xbuffer_NXINC), .READYO(cavlc_ready),
                        .TREADYO(tobytes_ready), .HVALID(header_valid) );
	
	//
	h264cavlc cavlc(.CLK(CLK), .CLK2(CLK2), .ENABLE(cavlc_enable), .READY(cavlc_ready), .VIN(cavlc_vin),
                    .NIN(cavlc_nin), .SIN(1'b0), .VE(cavlc_ve), .VL(cavlc_vl), .VALID(cavlc_valid),
                    .XSTATE(cavlc_xstate), .NOUT(cavlc_nout));

	//
	h264tobytes tobytes(.CLK(CLK), .VALID(tobytes_valid), .READY(tobytes_ready), .VE(tobytes_ve), 
                        .VL(tobytes_vl), .BYTE(tobytes_byte), .STROBE(tobytes_strobe), .DONE(tobytes_DONE));
	
	tobytes_ve <= b"00000"&header_ve when header_valid='1' else
					cavlc_ve when cavlc_valid='1' else
					'0'&x"030080";		//align+done pattern
	tobytes_vl <= header_vl when header_valid='1' else
					cavlc_vl when cavlc_valid='1' else
					b"01000";			//8 bits (1 + 7 for align)
	tobytes_valid <= header_valid or align_VALID or cavlc_valid;
	//
process(CLK2)	//nout/nin processing for CAVLC
begin
	if rising_edge(CLK2) then
		if xbuffer_NLOAD='1' then
			ninleft(conv_integer(xbuffer_NY)) <= cavlc_NOUT;
			nintop(conv_integer(ninx&xbuffer_NX)) <= cavlc_NOUT;
		else
			ninl <= ninleft(conv_integer(xbuffer_NY));
			nint <= nintop(conv_integer(ninx&xbuffer_NX));
		end if;
		if top_NEWLINE='1' then
			ninx <= (others => '0');
		elsif xbuffer_NXINC='1' then
			ninx <= ninx+1;
		end if;
	end if;
end process;
	cavlc_NIN <=
		ninl when xbuffer_NV=1 else
		nint when xbuffer_NV=2 else
		ninsum(5 downto 1) when xbuffer_NV=3 else
		(others=>'0');
	ninsum <= ('0'&ninl) + ('0'&nint) + 1;
	//
process(CLK2)	//feedback
begin
	if rising_edge(CLK2) then
		//feedback: set toppix
		if recon_FBSTROBE='1' then
			toppix(conv_integer(mbx & intra4x4_XXO)) <= recon_FEEDB;
		end if;
		if intra4x4_MSTROBEO='1' then
			topmode(conv_integer(mbx & intra4x4_XXO)) <= intra4x4_MODEO;
		end if;
		if top_NEWLINE='1' then
			mbx <= (others => '0');
		elsif intra4x4_XXINC='1' then
			mbx <= mbx + 1;
		end if;
		//
		//chroma feedback: set toppixcc
		if recon_FBCSTROBE='1' then
			toppixcc(conv_integer(mbxcc & intra8x8cc_XXO)) <= recon_FEEDB;
		end if;
		if top_NEWLINE='1' then
			mbxcc <= (others => '0');
		elsif intra8x8cc_XXINC='1' then
			mbxcc <= mbxcc + 1;
		end if;
	end if;
end process;
	//
	// FOR SIMULATION...
	//
process		//generate CLK2, 100MHz will do for this sim, and CLK at 50MHz
begin
	CLK2 <= '0';
	wait for 5 ns;
	CLK2 <= '1';
	CLK <= not CLK;
	wait for 5 ns;
end process;
	//
process		//input
	file inb : bytefile open read_mode is "sample_int.yuv";
	variable c : character;
	variable sout : line;
	variable framenum : integer := 0;
	variable x : integer;
	variable y : integer;
	variable cx : integer;
	variable cy : integer;
	variable cuv : integer;
begin
	mainlp: while  ( not endfile(inb) and framenum < MAXFRAMES) or QP < MAXQP loop
		if QP /= MAXQP and framenum>0 then
			QP <= QP + 1;
			wait until rising_edge(CLK2);
			write(sout,string'("Reusing framenum: "));write(sout,framenum);
			write(sout,string'(".  Using QP: "));write(sout,conv_integer(QP)); 
			writeline(output,sout);
		else
			//a .yuv file has the y first (w x h) followed by the u (w/2 x h/2) then v (ditto).
			//so we read it all in before starting
			for y in 0 to IMGHEIGHT-1 loop
				for x in 0 to IMGWIDTH-1 loop
					read(inb,c);
					yvideo(x,y) := c;
				end loop;
				if IMGSKIP>0 then
					for x in 1 to IMGSKIP loop
						read(inb,c);
					end loop;
				end if;
			end loop;
			for y in 0 to IMGHEIGHT/2-1 loop
				for x in 0 to IMGWIDTH/2-1 loop
					read(inb,c);
					uvideo(x,y) := c;
				end loop;
				if IMGSKIP>0 then
					for x in 1 to IMGSKIP/2 loop
						read(inb,c);
					end loop;
				end if;
			end loop;
			for y in 0 to IMGHEIGHT/2-1 loop
				for x in 0 to IMGWIDTH/2-1 loop
					read(inb,c);
					vvideo(x,y) := c;
				end loop;
				if IMGSKIP>0 then
					for x in 1 to IMGSKIP/2 loop
						read(inb,c);
					end loop;
				end if;
			end loop;
			//ok: read in image ok
			wait until rising_edge(CLK2);
			framenum := framenum+1;
			write(sout,string'("Framenum: "));write(sout,framenum);write(sout,string'(" read in ok"));
			write(sout,string'(".  Using QP: "));write(sout,conv_integer(QP));
			writeline(output,sout);
		end if;
		//
		top_NEWLINE <= '1';
		top_NEWSLICE <= '1';
		x:=0;
		y:=0;
		cx := 0;
		cy := 0;
		cuv:= 0;
		wait until rising_edge(CLK2);
		//
		//now pump in the data as requested
 		while y < IMGHEIGHT or cy < IMGHEIGHT/2 loop
 			if top_NEWLINE='1' then
 				//x := 0;
 				//y := y - (y mod 16);
 				cx := 0;
 				cy := cy - (cy mod 8);
 				cuv := 0;
 			end if;
			if intra4x4_READYI='1' and y < IMGHEIGHT then
				wait until rising_edge(CLK2);	//simulate a little delay in data arriving
				intra4x4_STROBEI <= '1';
				top_NEWLINE <= '0';
				top_NEWSLICE <= '0';
				for j in 0 to 1 loop
					for i in 0 to 3 loop
						intra4x4_DATAI <=
							CONV_STD_LOGIC_VECTOR(character'POS(yvideo(x+3,y)),8) &
							CONV_STD_LOGIC_VECTOR(character'POS(yvideo(x+2,y)),8) &
							CONV_STD_LOGIC_VECTOR(character'POS(yvideo(x+1,y)),8) &
							CONV_STD_LOGIC_VECTOR(character'POS(yvideo(x,y)),8);
						wait until rising_edge(CLK2);
						x := x+4;
					end loop;
					x := x-16;		//back to start of line for next macroblock row
					y := y+1;
					
				end loop;
				intra4x4_STROBEI <= '0';
				if y mod 16 = 0 then	//completed macroblock
					x := x+16;
					y := y-16;			//next macroblock
					if x=IMGWIDTH then
						x := 0;			//next line
						y := y+16;
						//wait for 1 us;
						if xbuffer_DONE='0' then wait until xbuffer_DONE='1'; end if;
						top_NEWLINE <= '1';
						if verbosep then
							write(sout,string'("Newline pulsed, line "));write(sout,y);
							write(sout,string'(" ("));write(sout,y*100/IMGHEIGHT);write(sout,string'("%)"));
							writeline(output,sout);
						end if;
					end if;
				end if;
			end if;		// intra4x4_READYI
			if intra8x8cc_READYI='1' and cy<IMGHEIGHT/2 then
				wait until rising_edge(CLK2);	//simulate a little delay in data arriving
				intra8x8cc_STROBEI <= '1';
				for j in 0 to 3 loop
					for i in 0 to 1 loop
						if cuv=0 then
							intra8x8cc_DATAI <= 
								CONV_STD_LOGIC_VECTOR(character'POS(uvideo(cx+i*4+3,cy)),8) &
								CONV_STD_LOGIC_VECTOR(character'POS(uvideo(cx+i*4+2,cy)),8) &
								CONV_STD_LOGIC_VECTOR(character'POS(uvideo(cx+i*4+1,cy)),8) &
								CONV_STD_LOGIC_VECTOR(character'POS(uvideo(cx+i*4,cy)),8);
						else
							intra8x8cc_DATAI <= 
								CONV_STD_LOGIC_VECTOR(character'POS(vvideo(cx+i*4+3,cy)),8) &
								CONV_STD_LOGIC_VECTOR(character'POS(vvideo(cx+i*4+2,cy)),8) &
								CONV_STD_LOGIC_VECTOR(character'POS(vvideo(cx+i*4+1,cy)),8) &
								CONV_STD_LOGIC_VECTOR(character'POS(vvideo(cx+i*4,cy)),8);
						end if;
						wait until rising_edge(CLK2);
					end loop;
					cy := cy+1;
				end loop;
				intra8x8cc_STROBEI <= '0';
				if cy mod 8 = 0 then
					if cuv=0 then
						cy := cy-8;
						cuv := 1;
					else
						cuv := 0;
						cy := cy-8;
						cx := cx+8;
						if cx=IMGWIDTH/2 then
							cx := 0;			//next line
							cy := cy+8;
						end if;
					end if;
				end if;
			end if;//intra8x8cc_READYI
			//iiy <= y;
			//ccy <= cy;
			wait until rising_edge(CLK2);
		end loop;
		if verbosep then
			write(sout,string'("Done push of data into intra4x4 and intra8x8cc"));
			writeline(output,sout);
		end if;
		if xbuffer_DONE='0' then
			wait until xbuffer_DONE='1';
		end if;
		for w in 1 to 32 loop
			wait until rising_edge(CLK);
		end loop;
		wait until rising_edge(CLK);
		align_VALID <= '1';		//force ALIGN through (slower CLK rate)
		wait until rising_edge(CLK);
		align_VALID <= '0';
		wait until rising_edge(CLK);
		if verbosep then
			write(sout,string'("Done align at end of NAL"));
			writeline(output,sout);
		end if;
		if tobytes_DONE='0' then
			wait until tobytes_DONE='1';
		end if;
		wait until rising_edge(CLK);
		//write(sout,"Got DONE flag");
		//writeline(output,sout);
		wait until rising_edge(CLK);
		//
	end loop;
	write(sout,framenum);write(sout,string'(" frames processed."));
	writeline(output,sout);
	assert FALSE report "DONE" severity FAILURE;
end process;

endmodule